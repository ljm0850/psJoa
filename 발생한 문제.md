# 백엔드
## mySQL 연결
- mySQL 설치 및 초기화, 시작
```
brew install mysql
mysql_install_db --verbose --user=`whoami` --basedir="$(brew --prefix mysql)" --datadir=/usr/local/var/mysql --tmpdir=/tmp
brew services start mysql 혹은 mysql.server start
```
- `mysql_secure_installation` : mySQL초기 설정
- `mysql -u root -p` : mySQL 접속
- 데이터베이스와 사용자 설정 (예시)
```
CREATE DATABASE your_database_name CHARACTER SET UTF8MB4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'your_username'@'localhost' IDENTIFIED BY 'your_password';
GRANT ALL PRIVILEGES ON your_database_name.* TO 'your_username'@'localhost';
FLUSH PRIVILEGES;
EXIT;
```
- `pip install mysqlclient` : mySQL과 통신할 라이브러리
    - 문제발생 => 의존성 설치
    ```
    brew install mysql
    brew install openssl
    brew install pkg-config
    brew link --force openssl
    ```
    - 환경변수 설정
    ```
    export LDFLAGS="-L/usr/local/opt/openssl/lib"
    export CPPFLAGS="-I/usr/local/opt/openssl/include"
    export PATH="/usr/local/opt/openssl/bin:$PATH"
    ```
- settings.py 설정 (아래는 예시)
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'db이름',
        'USER': 'db로그인 유저',
        'PASSWORD': '비번',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
```
- 이후 마이그레이션

## SETTINS.PY 암호화
- `pip install python-decouple` : 라이브러리 설치
- `.env` : 파일 생성 후 값 입력, `DB_NAME=db이름` 형식
- settings.py 변경
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': config('DB_NAME', default='your_database_name!!!!'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST'),
        'PORT': config('DB_PORT', cast=int),
    }
}
```
## POSTMAN CSRF
- POSTMAN을 이용하여 회원가입 API를 테스트
- 한번 생성 된 이후에는 에러 "detail": "CSRF Failed: CSRF token missing."를 반환
- 브라우저를 이용하여 접근되는 Django REST Framework 웹 화면에서는 잘 작동
- 확인해본 결과 POSTMAN의 헤더 쿠키에 저장된 CSRF 정보 삭제시 잘 작동

## 회원 가입시 nickname의 not null이 적용 안됨
- Serialize를 커스텀 하고, 이를 등록하여 사용했으나 잘 안됨
- 현재는 AbstractUser를 상속받아 사용하고 있는데, 여기서 `if nickname == null : arise` 같은 코드가 없기에 발생하는 문제라고 판단됨
    - 그렇다면 이를 오버라이드 해서 처리하면 되지 않을까?
    - 굳이 이렇게 까지 해서 쓸거라면 차라리 유저를 AbstractBaseUser를 상속받아 전부다 커스텀 하는게 낫지 않나? 라는 결론